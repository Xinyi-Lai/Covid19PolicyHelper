---
title: "final_proj_report"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r, message=FALSE, warning=FALSE}
library(readr)
dat = read_csv("new.csv")
dat = na.omit(dat)
dat$floor = as.numeric(matrix(unlist(strsplit(dat$floor, " ")), ncol = 2, byrow = TRUE)[ , 2])
dat = subset(dat, select = c(price, square, livingRoom, drawingRoom, kitchen, bathRoom, floor, buildingType, constructionTime, renovationCondition, buildingStructure, ladderRatio, elevator, subway, district))
dat$buildingType = as.factor(dat$buildingType)
dat$renovationCondition = as.factor(dat$renovationCondition)
dat$buildingStructure = as.factor(dat$buildingStructure)
dat$elevator = as.factor(dat$elevator)
dat$subway = as.factor(dat$subway)
dat$district = as.factor(dat$district)
dat$constructionTime = as.numeric(dat$constructionTime)
dat = na.omit(dat)
dat = subset(dat, constructionTime > 2010)
dat = droplevels(dat)

write.csv(dat, file = "dat.csv")


num_obs = nrow(dat)
num_trn = round(num_obs * 0.60)
set.seed(42)
trn_idx = sample(num_obs, num_trn)
dat_trn = dat[trn_idx, ]
dat_tst = dat[-trn_idx, ]
write.csv(dat_trn, file = "dat_trn.csv")
write.csv(dat_tst, file = "dat_tst.csv")

## training data cross-validation
full_model
AIC-backward
BIC-backward

## model diagnostic
# bptest (fitted-residual)
# shapiro (qqnorm)
# remove outliers

# loocv-rmse
# adj.r.squared

## testing data
# adj.r.squared
# RMSE

pairs(dat_trn)

m1 = lm(price ~ . - buildingStructure, data = dat_trn)
m2 = lm(price ~ (. - buildingStructure) ^ 2, data = dat_trn)
m3 = lm(
  price ~ poly(square, 2) + poly(ladderRatio, 2) + livingRoom + drawingRoom + kitchen + bathRoom + floor + buildingType + constructionTime + renovationCondition + ladderRatio + elevator + subway + district,
  data = dat_trn
)
m4 = lm(
  price ~ (poly(square, 2) + poly(ladderRatio, 2) + livingRoom + drawingRoom + kitchen + bathRoom + floor + buildingType + constructionTime + renovationCondition + elevator + subway + district) ^ 2,
  data = dat_trn
)
m5 = step(m4, trace = 0)
m6 = lm(
  price ~ poly(square, 2, raw = TRUE) * poly(ladderRatio, 2, raw = TRUE) +
    livingRoom + drawingRoom + bathRoom + buildingType + constructionTime + 
    elevator + subway + district + floor + square:livingRoom + 
    poly(square, 2, raw = TRUE):drawingRoom + I(square ^ 2):bathRoom + 
    I(square ^ 2):floor + poly(square, 2, raw = TRUE):buildingType + 
    I(square ^ 2):constructionTime + poly(ladderRatio, 2, raw = TRUE):bathRoom +
    poly(ladderRatio, 2, raw = TRUE):drawingRoom + ladderRatio:floor + 
    ladderRatio:buildingType + ladderRatio:constructionTime + livingRoom:floor + 
    livingRoom:subway + drawingRoom:floor + drawingRoom:constructionTime + 
    bathRoom:buildingType + floor:subway + buildingType:subway +
    constructionTime:elevator + constructionTime:district,
  data = dat_trn)
m7 = step(m6, trace = 0)
m8 = lm(
  price ~ poly(square, 2, raw = TRUE) * poly(ladderRatio, 2, raw = TRUE) + floor +
    livingRoom + drawingRoom + bathRoom + buildingType + constructionTime +
    elevator + subway + district + livingRoom:square + I(square ^ 2):drawingRoom +
    bathRoom:I(square ^ 2) + poly(square, 2, raw = TRUE):buildingType +
    poly(ladderRatio, 2, raw = TRUE):bathRoom + ladderRatio:drawingRoom +
    floor:ladderRatio + buildingType:ladderRatio + constructionTime:ladderRatio +
    livingRoom:subway + drawingRoom:floor + buildingType:subway +
    constructionTime:district,
  data = dat_trn)
m9 = lm(
  price ~ poly(square, 2, raw = TRUE) * poly(ladderRatio, 2, raw = TRUE) + floor +
    livingRoom + drawingRoom + bathRoom + buildingType + constructionTime +
    elevator + subway + district + livingRoom:square + I(square ^ 2):drawingRoom +
    bathRoom:I(square ^ 2) + poly(square, 2, raw = TRUE):buildingType +
    poly(ladderRatio, 2, raw = TRUE):bathRoom + ladderRatio:drawingRoom +
    floor:ladderRatio + buildingType:ladderRatio + constructionTime:ladderRatio +
    livingRoom:subway + drawingRoom:floor + buildingType:subway +
    constructionTime:district,
  data = dat_trn, subset = cooks.distance(m8) <= 4 / nrow(dat_trn))

m10 = lm(
  price ~ poly(square, 2, raw = TRUE) * poly(ladderRatio, 2, raw = TRUE) +
    livingRoom + bathRoom + buildingType + constructionTime +
    elevator + subway + district + livingRoom:square + bathRoom:I(square ^ 2) +
    poly(square, 2, raw = TRUE):buildingType +
    poly(ladderRatio, 2, raw = TRUE):bathRoom + buildingType:ladderRatio +
    constructionTime:ladderRatio + livingRoom:subway + buildingType:subway +
    constructionTime:district,
  data = dat_trn)

m11 = lm(
  price ~ poly(square, 2, raw = TRUE) * poly(ladderRatio, 2, raw = TRUE) +
    livingRoom + bathRoom + buildingType + constructionTime +
    elevator + subway + district + livingRoom:square + bathRoom:I(square ^ 2) +
    poly(square, 2, raw = TRUE):buildingType +
    poly(ladderRatio, 2, raw = TRUE):bathRoom + buildingType:ladderRatio +
    constructionTime:ladderRatio + livingRoom:subway + buildingType:subway +
    constructionTime:district,
  data = dat_trn, subset = cooks.distance(m10) <= 4 / nrow(dat_trn))

m12 = step(lm(price ~ 1, data = dat_trn), scope = price ~ (poly(square, 2) + poly(ladderRatio, 2) + livingRoom + drawingRoom + kitchen + bathRoom + floor + buildingType + constructionTime + renovationCondition + elevator + subway + district) ^ 2, direction = "forward", trace = 0)

m13 = step(lm(price ~ 1, data = dat_trn), scope = price ~ (square + I(square ^ 2) + livingRoom + drawingRoom + kitchen + bathRoom + floor + buildingType + constructionTime + renovationCondition + ladderRatio + I(ladderRatio ^ 2) + elevator + subway + district) ^ 2, direction = "forward")

m14 = step(lm(price ~ 1, data = dat_trn), scope = price ~ (square + livingRoom + drawingRoom + kitchen + bathRoom + floor + buildingType + constructionTime + renovationCondition + ladderRatio + elevator + subway + district) ^ 2, direction = "forward")

test_mod(m1)
test_mod(m2)
test_mod(m3)
test_mod(m4)
test_mod(m5)
test_mod(m6)
test_mod(m7)
test_mod(m8)
test_mod(m9)
test_mod(m10)
test_mod(m11)
test_mod(m12)
test_mod(m13)
test_mod(m14)


diagnostics(m9)

get_rmse = function(model) {
  sqrt(mean((dat_tst$price - predict(model, newdata = dat_tst))^ 2))
}

get_rmse(m4)
# get_rmse(m5)
get_rmse(m6)
get_rmse(m7)
get_rmse(m8)
get_rmse(m11)



int = lm(log(price) ~ (poly(square, 2) + poly(ladderRatio, 2) + district + livingRoom + drawingRoom + kitchen + bathRoom + elevator + subway + buildingType) ^ 2, data = dat_trn)

int_no_outlier = lm(log(price) ~ (poly(square, 2) + poly(ladderRatio, 2) + district + livingRoom + drawingRoom + kitchen + bathRoom + elevator + subway + buildingType) ^ 2, data = dat_trn, subset = cooks.distance(int) <= 4 / nrow(dat_trn))




plot(fitted(int), resid(int), pch = 20)
abline(h = 0, col = "red")
library(lmtest)
bptest(int_no_outlier) # p-value < 2.2e-16

qqnorm(resid(int))
qqline(resid(int))
shapiro.test(resid(int_no_outlier)) # p-value < 2.2e-16

select_aic = step(int, trace = 0)
select_bic = step(full_int2, k = log(nrow(dat_trn)), trace = 0)




```

