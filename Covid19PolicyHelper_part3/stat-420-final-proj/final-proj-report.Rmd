---
title: "final_proj_report"
output: html_document
---

```{r setup, echo = FALSE, message = FALSE, warning = FALSE}
options(scipen = 1, digits = 4, width = 80, fig.alin = "center")
```

```{r, message=FALSE, warning=FALSE}
library(readr)
dat = read_csv("new.csv")
dat = na.omit(dat)
dat$floor = as.numeric(matrix(unlist(strsplit(dat$floor, " ")), ncol = 2, byrow = TRUE)[ , 2])
dat = subset(dat, select = c(price, square, livingRoom, drawingRoom, kitchen, bathRoom, floor, buildingType, constructionTime, renovationCondition, buildingStructure, ladderRatio, elevator, subway, district))
dat$buildingType = as.factor(dat$buildingType)
dat$renovationCondition = as.factor(dat$renovationCondition)
dat$buildingStructure = as.factor(dat$buildingStructure)
dat$elevator = as.factor(dat$elevator)
dat$subway = as.factor(dat$subway)
dat$district = as.factor(dat$district)
dat$constructionTime = as.numeric(dat$constructionTime)
dat = na.omit(dat)
dat = subset(dat, constructionTime > 2010)

write.csv(dat, file = "dat.csv")

num_obs = nrow(dat)
num_trn = round(num_obs * 0.60)
set.seed(42)
trn_idx = sample(num_obs, num_trn)
dat_trn = dat[trn_idx, ]
dat_tst = dat[-trn_idx, ]
write.csv(dat_trn, file = "dat_trn.csv")
write.csv(dat_tst, file = "dat_tst.csv")

# ## training data cross-validation
# full_model
# AIC-backward
# BIC-backward
# 
# ## model diagnostic
# # bptest (fitted-residual)
# # shapiro (qqnorm)
# # remove outliers
# 
# set.seed(42)
# cv.glm() # smaller is better
# # adj.r.squared
# 
# ## testing data
# # adj.r.squared
# # RMSE
```

```{r}
mean(dat$price)
range(dat$price)
var(dat$price)
min(dat$price)
sum(dat$price < 1000)
sum(dat$price < 10000)
dat$price[which(dat$price < 1000)]
```

```{r}
View(dat)
str(dat)
```



```{r, fig.height=8, fig.width=8}
pairs(dat_tst, col = "dodgerblue")
```

```{r, fig.height=8, fig.width=8}
tmp = dat_tst
tmp = tmp[which(tmp$price > 10000), ]
tmp$price = log(tmp$price)
pairs(tmp, col = "dodgerblue")
```


```{r, message = FALSE, warning = FALSE}
# helper functions
library(lmtest)

get_bp_decision = function(model, alpha) {
  decide = unname(bptest(model)$p.value < alpha)
  ifelse(decide, "Reject", "Fail to Reject")
}

get_bp_pval = function(model) {
  bptest(model)$p.value
}

get_sw_decision = function(model, alpha) {
  decide = unname(shapiro.test(resid(model))$p.value < alpha)
  ifelse(decide, "Reject", "Fail to Reject")
}

get_sw_pval = function(model) {
  shapiro.test(resid(model))$p.value
}

get_num_params = function(model) {
  length(coef(model))
}

get_loocv_rmse = function(model) {
  sqrt(mean((resid(model) / (1 - hatvalues(model))) ^ 2))
}

get_loocv_rmse_log = function(model) {
  sqrt(mean(((exp(fitted(model)) - exp(model$model$`log(price)`)) / (1 - hatvalues(model))) ^ 2))
}

get_adj_r2 = function(model) {
  summary(model)$adj.r.squared
}

test_mod = function(model, is_log = TRUE){
  round(c(loocv_rmse = ifelse(is_log, get_loocv_rmse_log(model), get_loocv_rmse(model)), 
    adj_r2 = get_adj_r2(model), 
    bp_pval = get_bp_pval(model), 
    sw_pval = get_sw_pval(model), 
    num_params = round(get_num_params(model), 1)), digits = 10)
}

diagnostics = function(model, pcol = "grey", lcol = "dodgerblue", alpha = 0.05, plotit = TRUE, testit = FALSE){
  if (plotit){
    par(mfrow = c(1, 2), pty="s")
    
    plot(fitted(model), resid(model), col = "grey", pch = 20, 
         xlab = "Fitted", ylab = "Residual", 
         main = "Fitted versus Residuals")
    abline(h = 0, col = "darkorange", lwd = 2)
    
    qqnorm(resid(model), col = pcol)
    qqline(resid(model), col = lcol, lwd = 2)
  }
  if (testit){
    list(p_val = shapiro.test(resid(model))$p, 
         decision = ifelse(test = shapiro.test(resid(model))$p < alpha, 
                           yes = "Reject", no = "Fail to Reject"))
  }
}
```


```{r}
# price, square, livingRoom, drawingRoom, kitchen, bathRoom, floor, buildingType, constructionTime, renovationCondition, buildingStructure, ladderRatio, elevator, subway, district
mod_log_full = lm(price ~ . ^ 2, data = dat_trn)
```

```{r}
# all 1st degree terms and two-way interactions
mod_1 = mod_log_full
# small polynomial model (log response)
mod_2 = lm(price ~ poly(square, 2) + poly(ladderRatio, 2) + district + livingRoom + drawingRoom + kitchen + bathRoom + elevator + subway + buildingType, data = dat_trn)
# small polynomial model with outliers removed (log response)
mod_3 = lm(price ~ poly(square, 2) + poly(ladderRatio, 2) + district + livingRoom + drawingRoom + kitchen + bathRoom + elevator + subway + buildingType, data = dat_trn, subset = cooks.distance(mod_2) <= 4 / nrow(dat_trn))


# small polynomial model and all two-way interactions (log response)
mod_4 = lm(price ~ (poly(square, 2) + poly(ladderRatio, 2) + district + livingRoom + drawingRoom + kitchen + bathRoom + elevator + subway + buildingType) ^ 2, data = dat_trn)
# small polynomial model and all two-way interactions with outliers removed (log response)
mod_5 = lm(price ~ (poly(square, 2) + poly(ladderRatio, 2) + district + livingRoom + drawingRoom + kitchen + bathRoom + elevator + subway + buildingType) ^ 2, data = dat_trn, subset = cooks.distance(mod_4) <= 4 / nrow(dat_trn))
# aic from the last model
mod_6 = step(mod_5, trace = 0)
```

```{r}
test_mod(mod_1, is_log = FALSE)
test_mod(mod_2, is_log = FALSE)
test_mod(mod_3, is_log = FALSE)

test_mod(mod_4, is_log = FALSE)
test_mod(mod_5, is_log = FALSE)
test_mod(mod_6, is_log = FALSE)
```

```{r}
diagnostics(mod_1)
diagnostics(mod_2)
diagnostics(mod_3)
diagnostics(mod_4)
diagnostics(mod_5)
diagnostics(mod_6)
```

```{r}
summary(mod_1)
summary(mod_2)
summary(mod_3)
summary(mod_4)
summary(mod_5)
summary(mod_6)
```


```{r}
mod_9 = step(mod_7, direction = "forward", trace = 0, 
             scope = price ~ (. + I(kitchen ^ 2) + I(livingRoom ^ 2) + I(ladderRatio ^ 2)) ^ 2)
```
```{r}
mod_10 = lm(formula = log(price) ~ poly(square, 2) + poly(ladderRatio, 
    2) + district + livingRoom + drawingRoom + kitchen + bathRoom + 
    elevator + subway + buildingType + poly(square, 2):poly(ladderRatio, 
    2) + poly(square, 2):district + poly(square, 2):drawingRoom + 
    poly(square, 2):bathRoom + poly(square, 2):elevator + poly(square, 
    2):subway + poly(square, 2):buildingType + poly(ladderRatio, 
    2):district + poly(ladderRatio, 2):livingRoom + poly(ladderRatio, 
    2):kitchen + poly(ladderRatio, 2):bathRoom + poly(ladderRatio, 
    2):elevator + poly(ladderRatio, 2):buildingType + 
    livingRoom:drawingRoom + drawingRoom:buildingType + kitchen:bathRoom + 
    bathRoom:subway + bathRoom:buildingType + elevator:subway + 
    elevator:buildingType + subway:buildingType, data = dat_trn, 
    subset = cooks.distance(mod_4) <= 4/nrow(dat_trn))
```


```{r}
test_mod(mod_9, is_log = FALSE)
test_mod(mod_10, is_log = FALSE)

summary(mod_9)
summary(mod_10)
```

```{r}
diagnostics(mod_9)
```




```{r}
# price, square, livingRoom, drawingRoom, kitchen, bathRoom, floor, buildingType, constructionTime, renovationCondition, buildingStructure, ladderRatio, elevator, subway, district

# some very small models
mod_7 = lm(price ~ square + poly(ladderRatio, 2) + district + constructionTime + 
             kitchen + bathRoom + 
             buildingType + elevator + renovationCondition + subway + 
             I(kitchen ^ 2) + I(livingRoom ^ 2) + 
             kitchen:subway + 
             buildingType:subway + 
             elevator:subway + 
             renovationCondition:subway + 
             square:floor + 
             square:constructionTime + 
             square:ladderRatio + 
             square:subway + 
             livingRoom:kitchen + 
             livingRoom:bathRoom + 
             livingRoom:ladderRatio + 
             constructionTime:district, 
           data = dat_trn)

mod_8 = lm(price ~ square + poly(ladderRatio, 2) + district + constructionTime + 
             kitchen + bathRoom + 
             buildingType + elevator + renovationCondition + subway + 
             I(kitchen ^ 2) + I(livingRoom ^ 2) + 
             kitchen:subway + 
             buildingType:subway + 
             elevator:subway + 
             renovationCondition:subway + 
             square:floor + 
             square:constructionTime + 
             square:ladderRatio + 
             square:subway + 
             livingRoom:kitchen + 
             livingRoom:bathRoom + 
             livingRoom:ladderRatio + 
             constructionTime:district + 
             square:ladderRatio:district, 
           data = dat_trn)

test_mod(mod_7, is_log = FALSE)
test_mod(mod_8, is_log = FALSE)

summary(mod_7)
summary(mod_8) 
```
```{r}
diagnostics(mod_7)
diagnostics(mod_8)
```


```{r}
m8 = lm(price ~ poly(square, 2, raw = TRUE) * poly(ladderRatio, 2, raw = TRUE) + floor +
    livingRoom + drawingRoom + bathRoom + buildingType + constructionTime +
    elevator + subway + district + livingRoom:square + I(square ^ 2):drawingRoom +
    bathRoom:I(square ^ 2) + poly(square, 2, raw = TRUE):buildingType +
    poly(ladderRatio, 2, raw = TRUE):bathRoom + ladderRatio:drawingRoom +
    floor:ladderRatio + buildingType:ladderRatio + constructionTime:ladderRatio +
    livingRoom:subway + drawingRoom:floor + buildingType:subway +
    constructionTime:district,
  data = dat_trn)

m9 = lm(price ~ poly(square, 2, raw = TRUE) * poly(ladderRatio, 2, raw = TRUE) +
    livingRoom + drawingRoom + bathRoom + buildingType + constructionTime +
    elevator + subway + district + livingRoom:square + I(square ^ 2):drawingRoom +
    bathRoom:I(square ^ 2) + poly(square, 2, raw = TRUE):buildingType +
    poly(ladderRatio, 2, raw = TRUE):bathRoom + ladderRatio:drawingRoom +
    floor:ladderRatio + buildingType:ladderRatio + constructionTime:ladderRatio +
    livingRoom:subway + drawingRoom:floor + buildingType:subway +
    constructionTime:district,
  data = dat_trn)

test_mod(m8, is_log = FALSE)
test_mod(m9, is_log = FALSE)
summary(m8)
summary(m9)
```




